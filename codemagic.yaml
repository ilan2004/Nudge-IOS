workflows:
  ios-unsigned-build:
    name: iOS Unsigned Build
    max_build_duration: 60
    instance_type: mac_mini_m1
    environment:
      vars:
        XCODE_PROJECT: "Nudge.xcodeproj"
        XCODE_SCHEME: "Nudge"
        BUNDLE_ID: "com.ilan.nudgeapp.Z83Y9VJTKH"
        # Backend base URL (override in Codemagic UI per environment)
        API_BASE_URL: "https://api-dev.nudge.starshape.in"
      xcode: latest
      cocoapods: default
    scripts:
      - name: Prepare for unsigned build
        script: |
          echo "Preparing for unsigned build - code signing disabled"
          echo "API_BASE_URL will be injected into Info.plist via build setting expansion. Current: $API_BASE_URL"
      - name: Get CocoaPods dependencies (if any)
        script: |
          if [ -f "Podfile" ]; then
            pod install
          fi
      - name: Validate project presence (non-fatal)
        script: |
          echo "PWD: $PWD"
          ls -la || true
          if [ -d "Core" ]; then ls -la Core || true; fi
          if [ -d "Features" ]; then ls -la Features || true; fi
          if [ -d "UI" ]; then ls -la UI || true; fi
          if [ -d "Resources" ]; then ls -la Resources || true; fi
          if [ ! -d "$XCODE_PROJECT" ]; then echo "Warning: $XCODE_PROJECT not found"; fi
      - name: Ensure Friends files are in Xcode target (auto-add via xcodeproj)
        script: |
          echo "Installing xcodeproj gem to modify project file..."
          gem install xcodeproj -N
          ruby - <<'RUBY'
          require 'xcodeproj'
          proj_path = 'Nudge.xcodeproj'
          project = Xcodeproj::Project.open(proj_path)

          # Resolve target by scheme name or fallback to first
          scheme_name = ENV['XCODE_SCHEME'] || 'Nudge'
          target = project.targets.find { |t| t.name == scheme_name } || project.targets.first
          raise "No targets found in project" unless target

          friends_files = [
            'Features/Friends/FriendsView.swift',
            'Features/Friends/FriendModel.swift',
            'Features/Friends/FriendCard.swift',
            'Features/Friends/FriendDetailOverlay.swift'
          ]
          extension_files = [
            'UI/Extensions/View+CornerRadius.swift'
          ]

          # 1) Remove incorrect duplicate path references like Features/Features or UI/UI,
          #    and any refs pointing to paths that don't exist in the checkout.
          all_expected = friends_files + extension_files
          bad_refs = project.files.select do |f|
            next false unless f.path
            f.path.include?('Features/Features') || f.path.include?('UI/UI') ||
              (!File.exist?(f.real_path.to_s) && all_expected.any? { |p| File.basename(p) == File.basename(f.path) })
          end
          bad_refs.each do |ref|
            # Remove from build phase if present
            target.source_build_phase.files.select { |bf| bf.file_ref == ref }.each(&:remove_from_project)
            ref.remove_from_project
            puts "Removed bad ref: #{ref.path}"
          end

          # 2) Ensure the files exist in the repo; fail early with a clear message if missing.
          (friends_files + extension_files).each do |p|
            unless File.exist?(p)
              abort("Expected source file missing in repo: #{p}")
            end
          end

          # 3) Add clean file references directly under the main group (SOURCE_ROOT-relative paths)
          (friends_files + extension_files).each do |path|
            file_ref = project.files.find { |f| f.path == path && f.parent == project.main_group }
            file_ref ||= project.main_group.new_file(path)
            # Ensure file is in Sources build phase
            unless target.source_build_phase.files_references.include?(file_ref)
              target.add_file_references([file_ref])
              puts "Added to target: #{path}"
            else
              puts "Already in target: #{path}"
            end
          end

          project.save
          puts 'Project updated successfully.'
          RUBY
      - name: Build unsigned archive
        script: |
          mkdir -p "$PWD/build/ios/ipa"
          echo "Building with project: $XCODE_PROJECT, scheme: $XCODE_SCHEME"
          echo "Using API_BASE_URL=$API_BASE_URL"
          xcodebuild archive \
            -project "$XCODE_PROJECT" \
            -scheme "$XCODE_SCHEME" \
            -configuration Release \
            -destination "generic/platform=iOS" \
            -archivePath "$PWD/build/$XCODE_SCHEME.xcarchive" \
            CODE_SIGN_IDENTITY="" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            PROVISIONING_PROFILE="" \
            ENABLE_PREVIEWS=NO \
            DEVELOPMENT_ASSET_PATHS="" \
            API_BASE_URL="$API_BASE_URL" \
            -verbose
      - name: Ensure UIAppFonts includes Nippo-Regular (repair if missing)
        script: |
          APP_PATH="$PWD/build/$XCODE_SCHEME.xcarchive/Products/Applications/$XCODE_SCHEME.app"
          if [ ! -d "$APP_PATH" ]; then echo "Archive missing app at $APP_PATH" >&2; exit 1; fi
          echo "Listing bundled fonts:"; find "$APP_PATH" -iname "*.otf" -o -iname "*.ttf" -print || true
          # Create UIAppFonts if missing
          if ! /usr/libexec/PlistBuddy -c 'Print :UIAppFonts' "$APP_PATH/Info.plist" >/dev/null 2>&1
            echo "UIAppFonts key missing; creating..."
            /usr/libexec/PlistBuddy -c 'Add :UIAppFonts array' "$APP_PATH/Info.plist"
          fi
          # Add Nippo-Regular.otf if not present
          if ! /usr/libexec/PlistBuddy -c 'Print :UIAppFonts' "$APP_PATH/Info.plist" | grep -qi "Nippo-Regular.otf"; then
            echo "Adding Nippo-Regular.otf to UIAppFonts"
            /usr/libexec/PlistBuddy -c 'Add :UIAppFonts:0 string Nippo-Regular.otf' "$APP_PATH/Info.plist" || true
          fi
          # Ensure Tanker remains listed
          if ! /usr/libexec/PlistBuddy -c 'Print :UIAppFonts' "$APP_PATH/Info.plist" | grep -qi "Tanker-Regular.otf"; then
            /usr/libexec/PlistBuddy -c 'Add :UIAppFonts:0 string Tanker-Regular.otf' "$APP_PATH/Info.plist" || true
          fi
          echo "Final UIAppFonts:"; /usr/libexec/PlistBuddy -c 'Print :UIAppFonts' "$APP_PATH/Info.plist" || true
          # Ensure fonts exist in the app bundle (Copy Bundle Resources); repair if missing
          if ! find "$APP_PATH" -iname "Nippo-Regular.otf" | grep -q "."; then
            echo "Nippo-Regular.otf not found in archive; copying from source..."
            SRC_NIPPO="$PWD/Resources/Fonts/Nippo-Regular.otf"
            if [ -f "$SRC_NIPPO" ]; then
              cp -f "$SRC_NIPPO" "$APP_PATH/" && echo "Copied Nippo-Regular.otf into app bundle."
            else
              echo "Error: Source font not found at $SRC_NIPPO" >&2; exit 1
            fi
          fi
          if ! find "$APP_PATH" -iname "Tanker-Regular.otf" | grep -q "."; then
            echo "Tanker-Regular.otf not found in archive; copying from source..."
            SRC_TANKER="$PWD/Resources/Fonts/Tanker-Regular.otf"
            [ -f "$SRC_TANKER" ] && cp -f "$SRC_TANKER" "$APP_PATH/" && echo "Copied Tanker-Regular.otf into app bundle." || true
          fi
          echo "Post-repair bundled fonts:"; find "$APP_PATH" -maxdepth 1 -iname "*.otf" -o -iname "*.ttf" -print || true
          # Final validation
          find "$APP_PATH" -iname "Nippo-Regular.otf" | grep -q "." || { echo "Error: Nippo-Regular.otf still missing after repair" >&2; exit 1; }
      - name: Create IPA manually
        script: |
          echo "Archive succeeded! Creating IPA manually..."
          mkdir -p "$PWD/build/ios/ipa/Payload"
          APP_PATH="$PWD/build/$XCODE_SCHEME.xcarchive/Products/Applications/$XCODE_SCHEME.app"
          if [ ! -d "$APP_PATH" ]; then
            echo "Error: App not found at $APP_PATH" >&2
            echo "Contents of archive Applications directory:"; ls -la "$PWD/build/$XCODE_SCHEME.xcarchive/Products/Applications" || true
            exit 1
          fi
          cp -R "$APP_PATH" "$PWD/build/ios/ipa/Payload/"
          (cd "$PWD/build/ios/ipa" && zip -r "$XCODE_SCHEME".ipa Payload)
          echo "✅ IPA created successfully!"
          ls -la "$PWD/build/ios/ipa"/*.ipa || true
    artifacts:
      - build/ios/ipa/*.ipa
      - build/*.xcarchive
    publishing:
      # Uncomment and configure if you want to publish to external services
      # slack:
      #   channel: '#ios-builds'
      #   notify_on_build_start: true
      #   notify:
      #     success: true
      #     failure: true
      email:
        recipients:
          - your-email@example.com # Replace with your email
        notify:
          success: true
          failure: true

  ios-testflight:
    name: iOS TestFlight (Automatic Signing)
    max_build_duration: 60
    instance_type: mac_mini_m1
    environment:
      vars:
        XCODE_PROJECT: "Nudge.xcodeproj"
        XCODE_SCHEME: "Nudge"
        BUNDLE_ID: "com.ilan.nudgeapp.Z83Y9VJTKH"
        DEVELOPMENT_TEAM: "Z83Y9VJTKH" # Your Apple Team ID
        API_BASE_URL: "https://api-dev.nudge.starshape.in"
      groups:
        - nudge # Contains APP_STORE_CONNECT_KEY_IDENTIFIER, APP_STORE_CONNECT_ISSUER_ID, APP_STORE_CONNECT_PRIVATE_KEY
      xcode: latest
      cocoapods: default
    scripts:
      - name: Install Codemagic CLI tools
        script: |
          pip3 install --user codemagic-cli-tools || pip3 install codemagic-cli-tools
          which xcode-project || echo "codemagic-cli-tools installed"
      - name: Install CocoaPods (if any)
        script: |
          if [ -f "Podfile" ]; then
            pod install
          fi
      - name: Ensure Friends files are in Xcode target (auto-add via xcodeproj)
        script: |
          echo "Installing xcodeproj gem to modify project file..."
          gem install xcodeproj -N
          ruby - <<'RUBY'
          require 'xcodeproj'
          proj_path = 'Nudge.xcodeproj'
          project = Xcodeproj::Project.open(proj_path)

          # Resolve target by scheme name or fallback to first
          scheme_name = ENV['XCODE_SCHEME'] || 'Nudge'
          target = project.targets.find { |t| t.name == scheme_name } || project.targets.first
          raise "No targets found in project" unless target

          friends_files = [
            'Features/Friends/FriendsView.swift',
            'Features/Friends/FriendModel.swift',
            'Features/Friends/FriendCard.swift',
            'Features/Friends/FriendDetailOverlay.swift'
          ]
          extension_files = [
            'UI/Extensions/View+CornerRadius.swift'
          ]

          # Remove incorrect or broken refs
          all_expected = friends_files + extension_files
          bad_refs = project.files.select do |f|
            next false unless f.path
            f.path.include?('Features/Features') || f.path.include?('UI/UI') ||
              (!File.exist?(f.real_path.to_s) && all_expected.any? { |p| File.basename(p) == File.basename(f.path) })
          end
          bad_refs.each do |ref|
            target.source_build_phase.files.select { |bf| bf.file_ref == ref }.each(&:remove_from_project)
            ref.remove_from_project
            puts "Removed bad ref: #{ref.path}"
          end

          # Ensure files exist
          (friends_files + extension_files).each do |p|
            abort("Expected source file missing in repo: #{p}") unless File.exist?(p)
          end

          # Add clean file refs under main group and to Sources
          (friends_files + extension_files).each do |path|
            file_ref = project.files.find { |f| f.path == path && f.parent == project.main_group }
            file_ref ||= project.main_group.new_file(path)
            unless target.source_build_phase.files_references.include?(file_ref)
              target.add_file_references([file_ref])
              puts "Added to target: #{path}"
            else
              puts "Already in target: #{path}"
            end
          end

          project.save
          puts 'Project updated successfully.'
          RUBY
      - name: Set up signing (automatic via App Store Connect)
        script: |
          set -euo pipefail
          keychain initialize

          # Option A: Import Distribution certificate from env (works without UI access)
          if [ -n "${DIST_P12_BASE64:-}" ]; then
            echo "Importing distribution certificate from env..."
            echo "$DIST_P12_BASE64" | base64 --decode > dist.p12
            KEYCHAIN=$(security default-keychain -d user | tr -d '" ')
            [ -n "$KEYCHAIN" ] || KEYCHAIN="$HOME/Library/codemagic-cli-tools/keychains/default.keychain-db"
            security import dist.p12 -P "${DIST_P12_PASSWORD:-}" -k "$KEYCHAIN" -T /usr/bin/codesign -T /usr/bin/security || {
              echo "Failed to import dist.p12" >&2; exit 1; }
            security set-key-partition-list -S apple-tool:,apple: -s -k "" "$KEYCHAIN" >/dev/null 2>&1 || true
          fi

          # Profiles via App Store Connect API (may fail if it tries to save certs without private key) — don't fail the build
          app-store-connect fetch-signing-files "$BUNDLE_ID" --type IOS_APP_STORE --create --issuer-id "$APP_STORE_CONNECT_ISSUER_ID" --key-id "$APP_STORE_CONNECT_KEY_IDENTIFIER" --private-key "$APP_STORE_CONNECT_PRIVATE_KEY" --verbose || true

          # Option B: Import certificates uploaded in Codemagic UI (Teams > Code signing identities)
          keychain add-certificates || true

          # Option C: Install provisioning profile from env if provided
          if [ -n "${DIST_MOBILEPROVISION_BASE64:-}" ]; then
            mkdir -p "$HOME/Library/MobileDevice/Provisioning Profiles"
            echo "$DIST_MOBILEPROVISION_BASE64" | base64 --decode > "$HOME/Library/MobileDevice/Provisioning Profiles/nudge_dist_profile.mobileprovision"
          fi

          # Verify we have a Distribution identity installed before proceeding
          if ! security find-identity -v -p codesigning | grep -q "Apple Distribution"; then
            echo "No Apple Distribution identity found in keychain. Ensure DIST_P12_BASE64/PASSWORD are set correctly or upload .p12 via Teams." >&2
            exit 1
          fi

          xcode-project use-profiles

          echo "Installed code signing identities:"; security find-identity -v -p codesigning || true
          echo "Installed provisioning profiles:"; ls -la ~/Library/MobileDevice/Provisioning\ Profiles || true
          # Fail fast if no App Store profile for this bundle id is present
          if ! ls -1 ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision >/dev/null 2>&1; then
            echo "No provisioning profiles installed. Provide APP_STORE_CONNECT_* with permissions or set DIST_MOBILEPROVISION_BASE64." >&2
            exit 1
          fi
      - name: Generate App Icons
        script: |
          set -euo pipefail
          SRC_ICON="$PWD/Resources/Images/Nudge ios.png"
          DEST_DIR="$PWD/App/Assets.xcassets/AppIcon.appiconset"
          [ -f "$SRC_ICON" ] || { echo "Source icon not found at $SRC_ICON" >&2; exit 1; }
          mkdir -p "$DEST_DIR"
          gen() { local size=$1; local name=$2; sips -z "$size" "$size" "$SRC_ICON" --out "$DEST_DIR/$name" >/dev/null; }
          gen 20 icon-20-ipad.png
          gen 29 icon-29.png
          gen 40 icon-40.png
          gen 58 icon-29@2x.png
          gen 60 icon-20@3x.png
          gen 76 icon-76.png
          gen 80 icon-40@2x.png
          gen 87 icon-29@3x.png
          gen 120 icon-60@2x.png
          gen 152 icon-76@2x.png
          gen 167 icon-83.5@2x.png
          gen 180 icon-60@3x.png
          cp -f "$SRC_ICON" "$DEST_DIR/ios-marketing-1024.png" || true
          cat > "$DEST_DIR/Contents.json" <<'JSON'
          {
            "images" : [
              { "size" : "20x20", "idiom" : "iphone", "filename" : "icon-20@3x.png", "scale" : "3x" },
              { "size" : "20x20", "idiom" : "ipad",   "filename" : "icon-20-ipad.png", "scale" : "1x" },
              { "size" : "20x20", "idiom" : "ipad",   "filename" : "icon-40.png", "scale" : "2x" },

              { "size" : "29x29", "idiom" : "iphone", "filename" : "icon-29@2x.png", "scale" : "2x" },
              { "size" : "29x29", "idiom" : "iphone", "filename" : "icon-29@3x.png", "scale" : "3x" },
              { "size" : "29x29", "idiom" : "ipad",   "filename" : "icon-29.png", "scale" : "1x" },
              { "size" : "29x29", "idiom" : "ipad",   "filename" : "icon-58.png", "scale" : "2x" },

              { "size" : "40x40", "idiom" : "iphone", "filename" : "icon-40@2x.png", "scale" : "2x" },
              { "size" : "40x40", "idiom" : "iphone", "filename" : "icon-60@3x.png", "scale" : "3x" },
              { "size" : "40x40", "idiom" : "ipad",   "filename" : "icon-40.png", "scale" : "1x" },
              { "size" : "40x40", "idiom" : "ipad",   "filename" : "icon-80.png", "scale" : "2x" },

              { "size" : "60x60", "idiom" : "iphone", "filename" : "icon-60@2x.png", "scale" : "2x" },
              { "size" : "60x60", "idiom" : "iphone", "filename" : "icon-60@3x.png", "scale" : "3x" },

              { "size" : "76x76", "idiom" : "ipad",   "filename" : "icon-76.png", "scale" : "1x" },
              { "size" : "76x76", "idiom" : "ipad",   "filename" : "icon-76@2x.png", "scale" : "2x" },

              { "size" : "83.5x83.5", "idiom" : "ipad", "filename" : "icon-83.5@2x.png", "scale" : "2x" },

              { "size" : "1024x1024", "idiom" : "ios-marketing", "filename" : "ios-marketing-1024.png", "scale" : "1x" }
            ],
            "info" : { "version" : 1, "author" : "xcode" }
          }
          JSON
      - name: Build archive (Release)
        script: |
          xcodebuild archive \
            -project "$XCODE_PROJECT" \
            -scheme "$XCODE_SCHEME" \
            -configuration Release \
            -destination "generic/platform=iOS" \
            -archivePath "$PWD/build/$XCODE_SCHEME.xcarchive" \
            PRODUCT_BUNDLE_IDENTIFIER="$BUNDLE_ID" \
            DEVELOPMENT_TEAM="$DEVELOPMENT_TEAM" \
            API_BASE_URL="$API_BASE_URL" \
            ASSETCATALOG_COMPILER_APPICON_NAME=AppIcon \
            -allowProvisioningUpdates \
            -quiet || exit 1
      - name: Export signed IPA (app-store)
        script: |
          set -euo pipefail
          # Prefer Codemagic CLI helper (auto-detects archive/export paths & profiles)
          xcode-project build-ipa \
            --project "$XCODE_PROJECT" \
            --scheme "$XCODE_SCHEME" \
            --verbose || {
              echo "build-ipa failed; falling back to xcodebuild -exportArchive" >&2
              # Resolve installed App Store provisioning profile name for this bundle id
              PROFILE_NAME="${DISTRIBUTION_PROFILE_NAME:-}"
              if [ -z "$PROFILE_NAME" ]; then
                for p in "$HOME"/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision; do
                [ -e "$p" ] || continue
                XML=$(security cms -D -i "$p")
                BID=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:application-identifier' /dev/stdin <<<"$XML" 2>/dev/null || true)
                NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' /dev/stdin <<<"$XML" 2>/dev/null || true)
                if [[ "$BID" == "${DEVELOPMENT_TEAM}.${BUNDLE_ID}" ]]; then
                  if ! /usr/libexec/PlistBuddy -c 'Print :ProvisionedDevices' /dev/stdin <<<"$XML" >/dev/null 2>&1; then
                    PROFILE_NAME="$NAME"; break
                  fi
                fi
              done
              fi
              if [ -z "$PROFILE_NAME" ]; then
                echo "No App Store profile installed for $BUNDLE_ID; ensure fetch-signing-files created and installed one." >&2
                ls -la "$HOME/Library/MobileDevice/Provisioning Profiles" || true
                exit 1
              fi
              # Create ExportOptions with manual signing using the resolved profile
              printf '%s\n' \
                '<?xml version="1.0" encoding="UTF-8"?>' \
                '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">' \
                '<plist version="1.0">' \
                '<dict>' \
                '  <key>method</key>' \
                '  <string>app-store-connect</string>' \
                '  <key>signingStyle</key>' \
                '  <string>manual</string>' \
                '  <key>teamID</key>' \
                "  <string>${DEVELOPMENT_TEAM}</string>" \
                '  <key>signingCertificate</key>' \
                '  <string>Apple Distribution</string>' \
                '  <key>provisioningProfiles</key>' \
                '  <dict>' \
                "    <key>${BUNDLE_ID}</key>" \
                "    <string>${PROFILE_NAME}</string>" \
                '  </dict>' \
                '  <key>uploadBitcode</key>' \
                '  <false/>' \
                '  <key>compileBitcode</key>' \
                '  <false/>' \
                '</dict>' \
                '</plist>' > ExportOptions.plist
              xcodebuild -exportArchive \
                -archivePath "$PWD/build/$XCODE_SCHEME.xcarchive" \
                -exportOptionsPlist ExportOptions.plist \
                -exportPath "$PWD/build/ios" \
                -quiet || exit 1
            }
          ls -la "$PWD/build/ios"/*.ipa || true
      - name: Upload to TestFlight via CLI
        script: |
          # Write the private key to a file, fixing escaped newlines if present
          printf '%s' "$APP_STORE_CONNECT_PRIVATE_KEY" | sed 's/\\n/\n/g' | tr -d '\r' > appstore_key.p8
          head -n1 appstore_key.p8 | grep -q 'BEGIN PRIVATE KEY' || { echo 'Invalid APP_STORE_CONNECT_PRIVATE_KEY content'; exit 1; }
          PRIV_KEY_CONTENT=$(cat appstore_key.p8)
          # Publish the IPA to TestFlight using Codemagic CLI tools
          IPA_PATH=$(ls -1 "$PWD/build/ios"/*.ipa | head -n1)
          app-store-connect publish \
            --issuer-id "$APP_STORE_CONNECT_ISSUER_ID" \
            --key-id "$APP_STORE_CONNECT_KEY_IDENTIFIER" \
            --private-key "$PRIV_KEY_CONTENT" \
            --path "$IPA_PATH" \
            --testflight \
            --beta-group "Internal Testers" \
            --platform IOS
    artifacts:
      - build/ios/*.ipa
      - build/*.xcarchive
