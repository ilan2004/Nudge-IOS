workflows:
  ios-unsigned-build:
    name: iOS Unsigned Build
    max_build_duration: 60
    instance_type: mac_mini_m1
    environment:
      vars:
        XCODE_PROJECT: "Nudge.xcodeproj"
        XCODE_SCHEME: "Nudge"
        BUNDLE_ID: "com.ilan.nudgeapp"
        # Backend base URL (override in Codemagic UI per environment)
        API_BASE_URL: "https://api-dev.nudge.starshape.in"
      xcode: latest
      cocoapods: default
    scripts:
      - name: Prepare for unsigned build
        script: |
          echo "Preparing for unsigned build - code signing disabled"
          echo "API_BASE_URL will be injected into Info.plist via build setting expansion. Current: $API_BASE_URL"
      - name: Get CocoaPods dependencies (if any)
        script: |
          if [ -f "Podfile" ]; then
            pod install
          fi
      - name: Validate project presence (non-fatal)
        script: |
          echo "PWD: $PWD"
          ls -la || true
          if [ -d "Core" ]; then ls -la Core || true; fi
          if [ -d "Features" ]; then ls -la Features || true; fi
          if [ -d "UI" ]; then ls -la UI || true; fi
          if [ -d "Resources" ]; then ls -la Resources || true; fi
          if [ ! -d "$XCODE_PROJECT" ]; then echo "Warning: $XCODE_PROJECT not found"; fi
      - name: Ensure Friends files are in Xcode target (auto-add via xcodeproj)
        script: |
          echo "Installing xcodeproj gem to modify project file..."
          gem install xcodeproj -N
          ruby - <<'RUBY'
          require 'xcodeproj'
          proj_path = 'Nudge.xcodeproj'
          project = Xcodeproj::Project.open(proj_path)

          # Resolve target by scheme name or fallback to first
          scheme_name = ENV['XCODE_SCHEME'] || 'Nudge'
          target = project.targets.find { |t| t.name == scheme_name } || project.targets.first
          raise "No targets found in project" unless target

          friends_files = [
            'Features/Friends/FriendsView.swift',
            'Features/Friends/FriendModel.swift',
            'Features/Friends/FriendCard.swift',
            'Features/Friends/FriendDetailOverlay.swift'
          ]
          extension_files = [
            'UI/Extensions/View+CornerRadius.swift'
          ]

          # 1) Remove incorrect duplicate path references like Features/Features or UI/UI,
          #    and any refs pointing to paths that don't exist in the checkout.
          all_expected = friends_files + extension_files
          bad_refs = project.files.select do |f|
            next false unless f.path
            f.path.include?('Features/Features') || f.path.include?('UI/UI') ||
              (!File.exist?(f.real_path.to_s) && all_expected.any? { |p| File.basename(p) == File.basename(f.path) })
          end
          bad_refs.each do |ref|
            # Remove from build phase if present
            target.source_build_phase.files.select { |bf| bf.file_ref == ref }.each(&:remove_from_project)
            ref.remove_from_project
            puts "Removed bad ref: #{ref.path}"
          end

          # 2) Ensure the files exist in the repo; fail early with a clear message if missing.
          (friends_files + extension_files).each do |p|
            unless File.exist?(p)
              abort("Expected source file missing in repo: #{p}")
            end
          end

          # 3) Add clean file references directly under the main group (SOURCE_ROOT-relative paths)
          (friends_files + extension_files).each do |path|
            file_ref = project.files.find { |f| f.path == path && f.parent == project.main_group }
            file_ref ||= project.main_group.new_file(path)
            # Ensure file is in Sources build phase
            unless target.source_build_phase.files_references.include?(file_ref)
              target.add_file_references([file_ref])
              puts "Added to target: #{path}"
            else
              puts "Already in target: #{path}"
            end
          end

          project.save
          puts 'Project updated successfully.'
          RUBY
      - name: Build unsigned archive
        script: |
          mkdir -p "$PWD/build/ios/ipa"
          echo "Building with project: $XCODE_PROJECT, scheme: $XCODE_SCHEME"
          echo "Using API_BASE_URL=$API_BASE_URL"
          xcodebuild archive \
            -project "$XCODE_PROJECT" \
            -scheme "$XCODE_SCHEME" \
            -configuration Release \
            -destination "generic/platform=iOS" \
            -archivePath "$PWD/build/$XCODE_SCHEME.xcarchive" \
            CODE_SIGN_IDENTITY="" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            PROVISIONING_PROFILE="" \
            ENABLE_PREVIEWS=NO \
            DEVELOPMENT_ASSET_PATHS="" \
            API_BASE_URL="$API_BASE_URL" \
            -verbose
      - name: Ensure UIAppFonts includes Nippo-Regular (repair if missing)
        script: |
          APP_PATH="$PWD/build/$XCODE_SCHEME.xcarchive/Products/Applications/$XCODE_SCHEME.app"
          if [ ! -d "$APP_PATH" ]; then echo "Archive missing app at $APP_PATH" >&2; exit 1; fi
          echo "Listing bundled fonts:"; find "$APP_PATH" -iname "*.otf" -o -iname "*.ttf" -print || true
          # Create UIAppFonts if missing
          if ! /usr/libexec/PlistBuddy -c 'Print :UIAppFonts' "$APP_PATH/Info.plist" >/dev/null 2>&1
            echo "UIAppFonts key missing; creating..."
            /usr/libexec/PlistBuddy -c 'Add :UIAppFonts array' "$APP_PATH/Info.plist"
          fi
          # Add Nippo-Regular.otf if not present
          if ! /usr/libexec/PlistBuddy -c 'Print :UIAppFonts' "$APP_PATH/Info.plist" | grep -qi "Nippo-Regular.otf"; then
            echo "Adding Nippo-Regular.otf to UIAppFonts"
            /usr/libexec/PlistBuddy -c 'Add :UIAppFonts:0 string Nippo-Regular.otf' "$APP_PATH/Info.plist" || true
          fi
          # Ensure Tanker remains listed
          if ! /usr/libexec/PlistBuddy -c 'Print :UIAppFonts' "$APP_PATH/Info.plist" | grep -qi "Tanker-Regular.otf"; then
            /usr/libexec/PlistBuddy -c 'Add :UIAppFonts:0 string Tanker-Regular.otf' "$APP_PATH/Info.plist" || true
          fi
          echo "Final UIAppFonts:"; /usr/libexec/PlistBuddy -c 'Print :UIAppFonts' "$APP_PATH/Info.plist" || true
          # Ensure fonts exist in the app bundle (Copy Bundle Resources); repair if missing
          if ! find "$APP_PATH" -iname "Nippo-Regular.otf" | grep -q "."; then
            echo "Nippo-Regular.otf not found in archive; copying from source..."
            SRC_NIPPO="$PWD/Resources/Fonts/Nippo-Regular.otf"
            if [ -f "$SRC_NIPPO" ]; then
              cp -f "$SRC_NIPPO" "$APP_PATH/" && echo "Copied Nippo-Regular.otf into app bundle."
            else
              echo "Error: Source font not found at $SRC_NIPPO" >&2; exit 1
            fi
          fi
          if ! find "$APP_PATH" -iname "Tanker-Regular.otf" | grep -q "."; then
            echo "Tanker-Regular.otf not found in archive; copying from source..."
            SRC_TANKER="$PWD/Resources/Fonts/Tanker-Regular.otf"
            [ -f "$SRC_TANKER" ] && cp -f "$SRC_TANKER" "$APP_PATH/" && echo "Copied Tanker-Regular.otf into app bundle." || true
          fi
          echo "Post-repair bundled fonts:"; find "$APP_PATH" -maxdepth 1 -iname "*.otf" -o -iname "*.ttf" -print || true
          # Final validation
          find "$APP_PATH" -iname "Nippo-Regular.otf" | grep -q "." || { echo "Error: Nippo-Regular.otf still missing after repair" >&2; exit 1; }
      - name: Create IPA manually
        script: |
          echo "Archive succeeded! Creating IPA manually..."
          mkdir -p "$PWD/build/ios/ipa/Payload"
          APP_PATH="$PWD/build/$XCODE_SCHEME.xcarchive/Products/Applications/$XCODE_SCHEME.app"
          if [ ! -d "$APP_PATH" ]; then
            echo "Error: App not found at $APP_PATH" >&2
            echo "Contents of archive Applications directory:"; ls -la "$PWD/build/$XCODE_SCHEME.xcarchive/Products/Applications" || true
            exit 1
          fi
          cp -R "$APP_PATH" "$PWD/build/ios/ipa/Payload/"
          (cd "$PWD/build/ios/ipa" && zip -r "$XCODE_SCHEME".ipa Payload)
          echo "âœ… IPA created successfully!"
          ls -la "$PWD/build/ios/ipa"/*.ipa || true
    artifacts:
      - build/ios/ipa/*.ipa
      - build/*.xcarchive
    publishing:
      # Uncomment and configure if you want to publish to external services
      # slack:
      #   channel: '#ios-builds'
      #   notify_on_build_start: true
      #   notify:
      #     success: true
      #     failure: true
      email:
        recipients:
          - your-email@example.com # Replace with your email
        notify:
          success: true
          failure: true

  ios-testflight:
    name: iOS TestFlight (Automatic Signing)
    max_build_duration: 60
    instance_type: mac_mini_m1
    environment:
      vars:
        XCODE_PROJECT: "Nudge.xcodeproj"
        XCODE_SCHEME: "Nudge"
        BUNDLE_ID: "com.ilan.nudgeapp"
        DEVELOPMENT_TEAM: "Z83Y9VJTKH" # Your Apple Team ID
        API_BASE_URL: "https://api-dev.nudge.starshape.in"
      groups:
        - nudge # Contains: APP_STORE_CONNECT_ISSUER_ID, APP_STORE_CONNECT_KEY_IDENTIFIER, APP_STORE_CONNECT_PRIVATE_KEY
      xcode: latest
      cocoapods: default
    scripts:
      - name: Install Codemagic CLI tools
        script: |
          pip3 install --user codemagic-cli-tools || pip3 install codemagic-cli-tools
          which xcode-project || echo "codemagic-cli-tools installed"
      - name: Install CocoaPods (if any)
        script: |
          if [ -f "Podfile" ]; then
            pod install
          fi
      - name: Set up signing (automatic via App Store Connect)
        script: |
          keychain initialize
          app-store-connect fetch-signing-files "$BUNDLE_ID" --type IOS_APP_STORE --create
          keychain add-certificates
          xcode-project use-profiles
      - name: Build archive (Release)
        script: |
          xcodebuild archive \
            -project "$XCODE_PROJECT" \
            -scheme "$XCODE_SCHEME" \
            -configuration Release \
            -destination "generic/platform=iOS" \
            -archivePath "$PWD/build/$XCODE_SCHEME.xcarchive" \
            DEVELOPMENT_TEAM="$DEVELOPMENT_TEAM" \
            API_BASE_URL="$API_BASE_URL" \
            -allowProvisioningUpdates \
            -quiet || exit 1
      - name: Export signed IPA (app-store)
        script: |
          cat > ExportOptions.plist <<EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key>
            <string>app-store</string>
            <key>signingStyle</key>
            <string>automatic</string>
            <key>teamID</key>
            <string>${DEVELOPMENT_TEAM}</string>
            <key>uploadBitcode</key>
            <false/>
            <key>compileBitcode</key>
            <false/>
          </dict>
          </plist>
          EOF
          xcodebuild -exportArchive \
            -archivePath "$PWD/build/$XCODE_SCHEME.xcarchive" \
            -exportOptionsPlist ExportOptions.plist \
            -exportPath "$PWD/build/ios" \
            -allowProvisioningUpdates \
            -quiet || exit 1
          ls -la "$PWD/build/ios"/*.ipa || true
    artifacts:
      - build/ios/*.ipa
      - build/*.xcarchive
    publishing:
      app_store_connect:
        api_key:
          key_id: $APP_STORE_CONNECT_KEY_IDENTIFIER
          issuer_id: $APP_STORE_CONNECT_ISSUER_ID
          key: $APP_STORE_CONNECT_PRIVATE_KEY
        submit_to_testflight: true
        beta_groups:
          - name: Internal Testers
        # optional metadata
        # app_id: 1234567890
      email:
        recipients:
          - your-email@example.com
        notify:
          success: true
          failure: true
