workflows:
  ios-unsigned-build:
    name: iOS Unsigned Build
    max_build_duration: 60
    instance_type: mac_mini_m1
    environment:
      vars:
        XCODE_PROJECT: "Nudge.xcodeproj"
        XCODE_SCHEME: "Nudge"
        BUNDLE_ID: "com.ilan2004.nudge"
        # Backend base URL (override in Codemagic UI per environment)
        API_BASE_URL: "https://api-dev.nudge.starshape.in"
      xcode: latest
      cocoapods: default
    scripts:
      - name: Prepare for unsigned build
        script: |
          echo "Preparing for unsigned build - code signing disabled"
          echo "API_BASE_URL will be injected into Info.plist via build setting expansion. Current: $API_BASE_URL"
      - name: Get CocoaPods dependencies (if any)
        script: |
          if [ -f "Podfile" ]; then
            pod install
          fi
      - name: Validate project presence (non-fatal)
        script: |
          echo "PWD: $PWD"
          ls -la || true
          if [ -d "Core" ]; then ls -la Core || true; fi
          if [ -d "Features" ]; then ls -la Features || true; fi
          if [ -d "UI" ]; then ls -la UI || true; fi
          if [ -d "Resources" ]; then ls -la Resources || true; fi
          if [ ! -d "$XCODE_PROJECT" ]; then echo "Warning: $XCODE_PROJECT not found"; fi
      - name: Ensure Friends files are in Xcode target (auto-add via xcodeproj)
        script: |
          echo "Installing xcodeproj gem to modify project file..."
          gem install xcodeproj -N
          ruby - <<'RUBY'
          require 'xcodeproj'
          proj_path = 'Nudge.xcodeproj'
          project = Xcodeproj::Project.open(proj_path)

          # Resolve target by scheme name or fallback to first
          scheme_name = ENV['XCODE_SCHEME'] || 'Nudge'
          target = project.targets.find { |t| t.name == scheme_name } || project.targets.first
          raise "No targets found in project" unless target

          def ensure_group(root, path)
            parts = path.split('/')
            grp = root
            parts.each do |name|
              grp = grp[name] || grp.new_group(name)
            end
            grp
          end

          friends_files = [
            'Features/Friends/FriendsView.swift',
            'Features/Friends/FriendModel.swift',
            'Features/Friends/FriendCard.swift',
            'Features/Friends/FriendDetailOverlay.swift'
          ]
          extension_files = [
            'UI/Extensions/View+CornerRadius.swift'
          ]

          # Ensure groups exist
          friends_group = ensure_group(project.main_group, 'Features/Friends')
          ext_group = ensure_group(project.main_group, 'UI/Extensions')

          # Add file references and to Sources build phase if missing
          (friends_files + extension_files).each do |path|
            # Decide target group based on path
            group = path.start_with?('UI/Extensions') ? ext_group : friends_group
            file_ref = project.files.find { |f| f.path == path } || group.new_file(path)
            in_sources = target.source_build_phase.files_references.include?(file_ref)
            unless in_sources
              target.add_file_references([file_ref])
              puts "Added to target: #{path}"
            else
              puts "Already in target: #{path}"
            end
          end

          project.save
          puts 'Project updated successfully.'
          RUBY
      - name: Build unsigned archive
        script: |
          mkdir -p "$PWD/build/ios/ipa"
          echo "Building with project: $XCODE_PROJECT, scheme: $XCODE_SCHEME"
          echo "Using API_BASE_URL=$API_BASE_URL"
          xcodebuild archive \
            -project "$XCODE_PROJECT" \
            -scheme "$XCODE_SCHEME" \
            -configuration Release \
            -destination "generic/platform=iOS" \
            -archivePath "$PWD/build/$XCODE_SCHEME.xcarchive" \
            CODE_SIGN_IDENTITY="" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            PROVISIONING_PROFILE="" \
            ENABLE_PREVIEWS=NO \
            DEVELOPMENT_ASSET_PATHS="" \
            API_BASE_URL="$API_BASE_URL" \
            -verbose
      - name: Ensure UIAppFonts includes Nippo-Regular (repair if missing)
        script: |
          APP_PATH="$PWD/build/$XCODE_SCHEME.xcarchive/Products/Applications/$XCODE_SCHEME.app"
          if [ ! -d "$APP_PATH" ]; then echo "Archive missing app at $APP_PATH" >&2; exit 1; fi
          echo "Listing bundled fonts:"; find "$APP_PATH" -iname "*.otf" -o -iname "*.ttf" -print || true
          # Create UIAppFonts if missing
          if ! /usr/libexec/PlistBuddy -c 'Print :UIAppFonts' "$APP_PATH/Info.plist" >/dev/null 2>&1; then
            echo "UIAppFonts key missing; creating..."
            /usr/libexec/PlistBuddy -c 'Add :UIAppFonts array' "$APP_PATH/Info.plist"
          fi
          # Add Nippo-Regular.otf if not present
          if ! /usr/libexec/PlistBuddy -c 'Print :UIAppFonts' "$APP_PATH/Info.plist" | grep -qi "Nippo-Regular.otf"; then
            echo "Adding Nippo-Regular.otf to UIAppFonts"
            /usr/libexec/PlistBuddy -c 'Add :UIAppFonts:0 string Nippo-Regular.otf' "$APP_PATH/Info.plist" || true
          fi
          # Ensure Tanker remains listed
          if ! /usr/libexec/PlistBuddy -c 'Print :UIAppFonts' "$APP_PATH/Info.plist" | grep -qi "Tanker-Regular.otf"; then
            /usr/libexec/PlistBuddy -c 'Add :UIAppFonts:0 string Tanker-Regular.otf' "$APP_PATH/Info.plist" || true
          fi
          echo "Final UIAppFonts:"; /usr/libexec/PlistBuddy -c 'Print :UIAppFonts' "$APP_PATH/Info.plist" || true
          # Ensure fonts exist in the app bundle (Copy Bundle Resources); repair if missing
          if ! find "$APP_PATH" -iname "Nippo-Regular.otf" | grep -q "."; then
            echo "Nippo-Regular.otf not found in archive; copying from source..."
            SRC_NIPPO="$PWD/Resources/Fonts/Nippo-Regular.otf"
            if [ -f "$SRC_NIPPO" ]; then
              cp -f "$SRC_NIPPO" "$APP_PATH/" && echo "Copied Nippo-Regular.otf into app bundle."
            else
              echo "Error: Source font not found at $SRC_NIPPO" >&2; exit 1
            fi
          fi
          if ! find "$APP_PATH" -iname "Tanker-Regular.otf" | grep -q "."; then
            echo "Tanker-Regular.otf not found in archive; copying from source..."
            SRC_TANKER="$PWD/Resources/Fonts/Tanker-Regular.otf"
            [ -f "$SRC_TANKER" ] && cp -f "$SRC_TANKER" "$APP_PATH/" && echo "Copied Tanker-Regular.otf into app bundle." || true
          fi
          echo "Post-repair bundled fonts:"; find "$APP_PATH" -maxdepth 1 -iname "*.otf" -o -iname "*.ttf" -print || true
          # Final validation
          find "$APP_PATH" -iname "Nippo-Regular.otf" | grep -q "." || { echo "Error: Nippo-Regular.otf still missing after repair" >&2; exit 1; }
      - name: Create IPA manually
        script: |
          echo "Archive succeeded! Creating IPA manually..."
          mkdir -p "$PWD/build/ios/ipa/Payload"
          APP_PATH="$PWD/build/$XCODE_SCHEME.xcarchive/Products/Applications/$XCODE_SCHEME.app"
          if [ ! -d "$APP_PATH" ]; then
            echo "Error: App not found at $APP_PATH" >&2
            echo "Contents of archive Applications directory:"; ls -la "$PWD/build/$XCODE_SCHEME.xcarchive/Products/Applications" || true
            exit 1
          fi
          cp -R "$APP_PATH" "$PWD/build/ios/ipa/Payload/"
          (cd "$PWD/build/ios/ipa" && zip -r "$XCODE_SCHEME".ipa Payload)
          echo "âœ… IPA created successfully!"
          ls -la "$PWD/build/ios/ipa"/*.ipa || true
    artifacts:
      - build/ios/ipa/*.ipa
      - build/*.xcarchive
    publishing:
      # Uncomment and configure if you want to publish to external services
      # slack:
      #   channel: '#ios-builds'
      #   notify_on_build_start: true
      #   notify:
      #     success: true
      #     failure: true
      email:
        recipients:
          - your-email@example.com # Replace with your email
        notify:
          success: true
          failure: true
